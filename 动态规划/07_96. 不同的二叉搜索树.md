# [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)



题解：

当 n = 1，有 1 棵树

当 n = 2，有 2 棵树

当 n = 3，有 3 棵树

再看看 n = 3 的情况：

- 当 1 为头结点，左子树和n=2的两棵树布局一样

- 当 3 为头节点，右子树和n为2的两棵树布局一样
- 当2为头结点，左右字数一个节点，和n=1的时候一棵树布局一样



dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量

元素1为头结点搜索树的数量 = 右⼦树有2个元素的搜索树数量 * 左⼦树有0个元素的搜索树数量

元素2为头结点搜索树的数量 = 右⼦树有1个元素的搜索树数量 * 左⼦树有1个元素的搜索树数量

元素3为头结点搜索树的数量 = 右⼦树有0个元素的搜索树数量 * 左⼦树有2个元素的搜索树数量



dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]



五大步骤：

1.确定db数组以及下标的意义

- dp[i] 从 1 到 i节点组成的二查搜索树的个数

2.确定递归公式

- dp[i] += dp[以j为头结点左⼦树节点数量] * dp[以j为头结

  点右⼦树节点数量] 
- dp[i] += dp[j - 1] * dp[i - j];

3.dp数组如何初始化

- dp[0] = 1

4.确定遍历顺序

- 从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之

  前节点数的状态。

  那么遍历i⾥⾯每⼀个数作为头结点的状态，⽤j来遍历。

5.举例推导dp数组

```js
[
  1, 1, 2, 5, 14 , 42
]
```



代码：

```js
const numTrees =(n) => {
    let dp = new Array(n+1).fill(0);
    dp[0] = 1;
    dp[1] = 1;

    for(let i = 2; i <= n; i++) {
        for(let j = 1; j <= i; j++) {
            dp[i] += dp[j-1] * dp[i-j];
        }
    }

    return dp[n];
};
```

